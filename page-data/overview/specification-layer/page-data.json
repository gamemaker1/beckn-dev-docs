{
    "componentChunkName": "component---src-templates-index-tsx",
    "path": "/overview/specification-layer",
    "result": {"data":{"mdx":{"id":"7c325e52-c1f8-5af0-9caa-9a062cdeed9e","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Beckn Protocol Specification\",\n  \"order\": 2\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"specification-layer\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#specification-layer\",\n    \"aria-label\": \"specification layer permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"specification layer\"), mdx(\"h2\", {\n    \"id\": \"topic-summary\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#topic-summary\",\n    \"aria-label\": \"topic summary permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Topic Summary\"), mdx(\"p\", null, \"Beckn Specification layer consists of the Core APIs, the Core schema, the Domain\\ntaxonomy, the Communication protocol, and the Authentication and Smart Contracts\\ncomponent.\"), mdx(\"p\", null, \"Core APIs include Transaction APIs which are modeled after the order lifecycle\\n(discovery order, fulfillment, post-fulfillment) and are asynchronous, and\\nSupporting APIs which are mostly synchronous.\"), mdx(\"p\", null, \"The Core schema specifies the structure of the data in the commerce interactions\\nand is modeled after the OpenAPI 3.0 specification. It is the data abstraction\\nlayer for the APIs.\"), mdx(\"p\", null, \"Domain taxonomies add industry-specific attributes to the elements of the Core\\nschema and specify the supported values at country, city, or network levels.\"), mdx(\"p\", null, \"The Communication protocol contains the Core API implementation rules that make\\npossible for a platform or app\\xA0 to become a part of a Beckn-enabled network.\"), mdx(\"p\", null, \"The Authentication and Smart Contracts component specifies the way in which\\nparticipants authenticate on the network and the conditions under which this is\\ndone.\"), mdx(\"h2\", {\n    \"id\": \"overview\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#overview\",\n    \"aria-label\": \"overview permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Overview\"), mdx(\"p\", null, \"The foundation layer of a Beckn network is the Specification layer. It comprises\\nof five components:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Core APIs\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Core schema\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Domain taxonomy\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Communication protocol\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Authentication and Smart Contracts\")), mdx(\"p\", null, \"They must be implemented by any platform that wants to be part of the open\\nnetwork.\"), mdx(\"p\", null, \"The\\xA0Core APIs\\xA0are a set of API specifications which define the various objects\\nused in a commerce transaction. These objects are abstracted to the highest\\npossible level -- the level of the concepts that are common to all commerce\\noperations, like \\\"order\\\", \\\"tracking\\\", \\\"payment\\\", and similar. Thus the Core\\nschema objects are domain-agnostic (industry-agnostic) by definition. They are\\nreused across the specific domains (industries) with less abstract meanings and\\nwith concrete values taken from the domain taxonomies.\"), mdx(\"p\", null, \"The\\xA0domain taxonomy\\xA0defines the industry-specific objects. For example, a\\ntaxonomy for an urban mobility network may expose as Providers taxi companies,\\ncar rental companies, car-pooling services, the city metropolitan, etc..\"), mdx(\"p\", null, \"The\\xA0Core\\xA0schema\\xA0consists of a set of schemas that give structure of the message\\npackets that are exchanged in the communication.\"), mdx(\"p\", null, \"The\\xA0Communication protocol\\xA0contains the rules for the implementation of the Core\\nAPIs. Any platform that wants to be part of a Beckn-enabled network must follow\\nthese rules.\"), mdx(\"p\", null, \"The\\xA0Authentication and Smart Contracts\\xA0component specifies the way and the\\nconditions for the participants to authenticate on the network, e.g. what are\\nthe authorized certification agencies and what data must be submitted to them,\\nwhat the authorization registries must be and how they must be maintained,\\nwhether certifications should expire, the renewal procedure, etc..\"), mdx(\"h2\", {\n    \"id\": \"core-apis\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#core-apis\",\n    \"aria-label\": \"core apis permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Core APIs\"), mdx(\"p\", null, \"Overview\\xA0Here is a list of Beckn core APIs:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Transaction\\xA0APIs\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Discovery\\xA0API\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Order\\xA0API\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Fulfilment\\xA0API\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Post-Fulfilment\\xA0API\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Supporting\\xA0APIs\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Network Security\\xA0API\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"BPP Meta\\xA0API\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Open Data\\xA0API (under development)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Certification\\xA0API (under development)\")))), mdx(\"p\", null, \"As evident from their names, the transaction APIs cover the four stages of the\\nlifecycle of a typical\\norder:\\xA0\", mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"https://developers.becknprotocol.io/wp-content/uploads/2021/07/core-api.jpg\",\n    \"alt\": null\n  })), mdx(\"p\", null, \"Every end-to-end commerce transaction can be categorized through these four\\nstages:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Discovery\\xA0-- involves searching for a provider or a catalog. Once the\\ncatalog is retrieved, one can browse the catalog using various filters and\\nparameters.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Order\\xA0-- the consumer constructs the order by selecting various items or\\noffers from a catalog; billing and shipping details are supplied, as well as\\nany supporting credentials if required. A confirmed order marks the end of\\nthis stage.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Fulfillment\\xA0-- the actual fulfillment of the order. This consists of events\\nlike delivery, tracking and, occasionally, cancelation. The completion of\\nthe delivery of an order marks the end of this stage.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Post-Fulfillment\\xA0-- activities like providing rating, contacting support, or\\ninitiating a return\")), mdx(\"p\", null, \"All transaction APIs are asynchronous, which means that the requested\\ninformation is not returned immediately in the same session and that there is a\\ncallback mechanism in place through which it is obtained.\"), mdx(\"p\", null, \"The Supporting APIs cover activities which are not themselves part of the order\\nlifecycle described above but enable or assist it. Typically, these APIs do not\\nnecessarily need to be called for every order. The data returned by them is\\ngenerally meant to be cached by the requester. Unlike the Transaction APIs, most\\nof the Supporting APIs are synchronous.\"), mdx(\"h2\", {\n    \"id\": \"transaction-apis\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#transaction-apis\",\n    \"aria-label\": \"transaction apis permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Transaction APIs\"), mdx(\"p\", null, \"As mentioned in the\\xA0Overview, every stage of the order lifecycle is completed by\\none of the Transaction APIs (if we set aside the functionalities of the\\nSupporting APIs), so these APIs emulate the typical order funnel, that is, from\\nsearch, to confirmation, to tracking, and up to rating.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"https://developers.becknprotocol.io/wp-content/uploads/2021/07/transaction-api.jpg\",\n    \"alt\": null\n  })), mdx(\"p\", null, \"At that, the Transaction APIs do not necessarily need to be called in the\\nsequence of the order lifecycle (discovery, order, fulfillment, post-fulfilment)\\nevery time: there are use cases when one might start, for example, by calling\\nthe Order API to confirm an order without going through searching and then\\nthrough selecting and then through initializing the order.\"), mdx(\"p\", null, \"The Transaction APIs realize the order lifecycle by operating asynchronously.\\nThis means that the request is not followed by an immediate response in the same\\nsession. Instead, an acknowledgement is returned, and the actual payload is\\nsupplied later to a callback API. This mode of operation is very much in line\\nwith the way in which commerce operations occur in the physical world. In fact,\\na response may take even days after the request was generated. For example, when\\nbooking a hotel during a peak season, a booking request does not necessarily\\nmean that the hotel has confirmed the booking: it may take up to 24 hours for\\nthe confirmation to be issued. Thus the async nature of these APIs.\"), mdx(\"p\", null, \"Expanding further on the nature of the Transaction APIs, two more things has to\\nbe pointed out. Transaction APIs are also:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Transport-layer-agnostic\\xA0-- not specific to any transport protocol. They can\\nbe easily implemented with any such protocol like HTTP, UDP, WebSocket, and\\nothers. (Do not be confused by the fact that most Beckn developer literature\\nshows the Beckn protocol in HTTP implementation: this is because, due to the\\npopularity of HTML, the typical implementations are for this protocol. Just\\nkeep in mind that it is just one option for the choice of transport protocol.)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Server-to-server\\xA0-- they are not called directly by a UI client (a mobile\\nphone app, browser, smart devices, etc.). This empowers the implementer to\\nflexibly customize the experience in whatever way they want it to be. For\\nexample, a single search request from a mobile app to a server might result in\\nmultiple API calls from the server to the network.\")), mdx(\"h2\", {\n    \"id\": \"core-schema\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#core-schema\",\n    \"aria-label\": \"core schema permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Core Schema\"), mdx(\"p\", null, \"The Core schema specifies the structure of the data in the commerce\\ninteractions. The definition of these objects is presented as a structured\\nschema for documentation and validation purposes and complies to the OpenAPI 3.0\\nspecification. The schema organizes that data that is passed in each of the Core\\nAPIs into a several hierarchical component levels:\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"https://developers.becknprotocol.io/wp-content/uploads/2021/07/core-schema.jpg\",\n    \"alt\": null\n  })), mdx(\"p\", null, \"Together, these levels of components form the Core schema which constitutes the\\ndata abstraction layer for the APIs.\"), mdx(\"p\", null, \"The top-level is a set of highly abstracted classes which form the main message\\nthat is passed in each API.\"), mdx(\"p\", null, \"In the mid-level, each of these objects becomes more detailed and specific as\\nthe various properties of the top-level objects are defined.\"), mdx(\"p\", null, \"Further down is the level of the schema primitives -- reusable objects that\\nspecify dimensions for the mid-level objects. For example, a location may mean\\nthe GPS coordinates of a place, an address, an area, or a particular 3-D object\\n(a building). Depending on context, the location object may be used in a various\\nplaces. For instance, a fulfillment object may have a location attribute which\\nspecifies the delivery area, whereas a provider may have a location attribute\\nthat indicates the whereabouts of a store. These objects are so general in their\\nmeaning that they are no longer specific to commerce -- \\\"location\\\", for instance\\nis by no means limited to commerce or any particular human activity.\"), mdx(\"p\", null, \"The bottom level represents the primitive data types of all platform entities.\\nThese data types, together with the adopted universal standards (IETF, JSON,\\nOpenAPI, ISO, Regex) through which the schema is defined, make for lesser\\ncommunication overhead when parsing messages.\"), mdx(\"h2\", {\n    \"id\": \"taxonomies\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#taxonomies\",\n    \"aria-label\": \"taxonomies permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Taxonomies\"), mdx(\"p\", null, \"Most real-life use cases cannot be represented by abstracted objects only. To\\neach of these objects, there has to be some domain-level context that gives\\nactual meaning to the nature and function of these objects. That variance across\\ndomains is accounted for by the application of taxonomies. These taxonomies add\\ndomain-specific attributes to the elements of the Core schema.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"https://developers.becknprotocol.io/wp-content/uploads/2021/07/taxonomies.jpg\",\n    \"alt\": null\n  })), mdx(\"p\", null, \"There is a particular nomenclature to these taxonomies which is constructed out\\nof a hierarchical layering of scopes, namely -- domain, country, city, and\\nnetwork. Every domain-specific attribute has a set of supported values that can\\nbe specified at country, city, or network levels. The list of supported values\\nfor each attribute can be listed on a public domain like a web site or in the\\nAPI itself in the form of allowed values specific to a particular city or\\nnetwork. For example, the city of New Delhi permits rickshaws as mode of travel,\\nwhereas Bangalore does not. So the list of supported modes in New Delhi or\\nBangalore should be present as a file in the protocol specifications repository\\nwhich anyone can access and implement. This list will continuously be updated as\\nnew modes of travel come along.\"), mdx(\"p\", null, \"The layering in taxonomies allows to create enumerations (enums), required\\nfields, allowed and default values, and domain-/region-/network-specific\\nstandards. For example, in the network mobility domain, as far as location is\\nconcerned, it suffices to specify the pick-up location in order to confirm an\\norder; in the domain of hyperlocal delivery however, the pickup location, as\\nwell as the drop location, are required. So these taxonomies must be very\\nclearly specified in each of these domains.\"), mdx(\"p\", null, \"The same holds true for the allowed values and defaults. Let's take for example\\nthe Fulfilment Type object. This object describes how an order is going to be\\nfulfilled and this is different in each domain. In retail, for example, the\\nvarious types of fulfilment include home delivery and store pick-up, but in\\nhealthcare, the fulfillment type might be any consultation or medical checkup.\\nSo the mode in which an order is being fulfilled varies across the domains,\\nwhich means that there has to be enums and default values assigned to each of\\nthe domain-specific taxonomies, and these enums and default values will, too,\\nvary across the domains. And then there can also be network-, domain-, and\\nregion -specific standards (as in the rickshaw example above).\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"https://developers.becknprotocol.io/wp-content/uploads/2021/07/domain-spec-tax.jpg\",\n    \"alt\": null\n  })), mdx(\"p\", null, \"So most of these settings must be available as a separate specifications which\\ncan be made retrievable via an API so a system integrator could be able to\\nsimply make an API call to get the taxonomy rules for a particular domain,\\ncountry, or network and use that additional layer in to validate their platform\\nor to create domain-specific validation layers in your in their own API.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"7c325e52-c1f8-5af0-9caa-9a062cdeed9e"}},
    "staticQueryHashes": ["2361188516","3649515864"]}